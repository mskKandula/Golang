version: "3.0"

services:
  server:
    container_name: "conn_server"
    # we want to use the image which is build from our Dockerfile
    build:
      context: .
      dockerfile: ./server/Dockerfile
    expose: ["9000"]
    ports:
      - "9000:9000"

    networks:
      - default
    # We mount the working dir into the container, handy for development
    # This is what makes the hot reloading work inside of a Docker container
    restart: always

  ngin:
    container_name: "conn_nginx"
    # we want to use the image which is build from our Dockerfile
    build:
      context: .
      dockerfile: ./nginx/Dockerfile
    expose: ["8020"]
    ports:
      - "8020:8020"
    networks:
      - default

    sysctls:
      net.ipv4.ip_local_port_range: 10000 65535
    # We mount the working dir into the container, handy for development
    # This is what makes the hot reloading work inside of a Docker container
    restart: always

  client:
    # container_name: "conn_client"
    # privileged: true
    # we want to use the image which is build from our Dockerfile
    build:
      context: .
      dockerfile: ./client/Dockerfile
    # we are depending on the mysql(db) & redis (cache)
    depends_on:
      - server

    networks:
      - default

    sysctls:
      net.ipv4.ip_local_port_range: 10000 65535

    deploy:
      mode: replicated
      replicas: 2

    # We mount the working dir into the container, handy for development
    restart: always

networks:
  default:
    driver: bridge
