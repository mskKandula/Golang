version: "3.0"

services:
  db:
    container_name: "conn_db"
    build:
      context: .
      dockerfile: ./MySQL/Dockerfile
    networks:
      - default
    restart: always
    expose: ["3306"]
    # setting some env vars
    environment:
      MYSQL_USER: "mohanak"
      MYSQL_ROOT_PASSWORD: "root"
      MYSQL_PASSWORD: "password123"
      MYSQL_DATABASE: "Conn"

    volumes:
      - mysql_data:/var/lib/mysql

  server:
    container_name: "conn_server"
    # we want to use the image which is build from our Dockerfile
    build:
      context: .
      dockerfile: ./server/Dockerfile
    expose: ["8000"]
    ports:
      - "8000:8000"
    depends_on:
      - db

    networks:
      - default
    # We mount the working dir into the container, handy for development
    # This is what makes the hot reloading work inside of a Docker container
    restart: always

  ngin:
    container_name: "conn_nginx"
    # we want to use the image which is build from our Dockerfile
    build:
      context: .
      dockerfile: ./nginx/Dockerfile
    expose: ["8020"]
    ports:
      - "8020:8020"
    depends_on:
      - client
      - server

    networks:
      - default

    sysctls:
      net.ipv4.ip_local_port_range: 10000 65535
    # We mount the working dir into the container, handy for development
    # This is what makes the hot reloading work inside of a Docker container
    restart: always

  client:
    # container_name: "conn_client"
    # privileged: true
    # we want to use the image which is build from our Dockerfile
    build:
      context: .
      dockerfile: ./client/Dockerfile
    # we are depending on the mysql(db) & redis (cache)
    depends_on:
      - server
      - db

    networks:
      - default

    sysctls:
      net.ipv4.ip_local_port_range: 10000 65535

    # We mount the working dir into the container, handy for development
    restart: always

networks:
  default:
    driver: bridge

volumes:
  mysql_data:
